### Exercise 04: Profiling

Файлы для сдачи: financial.py, financial_enhanced.py, profiling-sleep.txt, profiling-tottime.txt,
profiling-http.txt, profiling-ncalls.txt

Нет никаких шансов, что вы напишете код на 100% идеально в будущем без каких-либо возможностей для улучшения. Вам, скорее всего, придется выяснить, почему ваши скрипты не работают так быстро, как вам хотелось бы. И у нас есть вещь для таких целей - профилировщики. Согласно Википедии, профилирование - это форма динамического анализа программы, которая измеряет, например,
пространственную или временную сложность программы, использование определенных инструкций, или частоту и длительность вызовов функций. Чаще всего информация профилирования служит для оптимизации программы.

Помните свой сценарий из предыдущего упражнения? Давайте оптимизируем его. Даже если вы гуру программирования, была одна структура, которая была не очень эффективна (мы просили вас сделать это таким образом).

* Применив cProfile к вашему скрипту financial.py, получите таблицу используемых функций, отсортированную по убыванию общего времени, затраченного на их выполнение. Сохраните ее в файл profiling-sleep.txt.

    ![1](../images/1.png)

* Удалите строку с time.sleep(5) из вашего скрипта и запустите профилирование снова. Вы должны получить новую таблицу без встроенного метода time.sleep. Сохраните его в файле profiling-tottime.txt
* Попробуйте использовать другую библиотеку HTTP-клиента, чтобы увидеть, стал ли ваш скрипт быстрее. Сохраните новый скрипт в financial_enhanced.py. Сохраните результат профилирования в файле profiling-http.txt
* Получите ту же таблицу, но отсортированную в порядке убывания по количеству вызовов. Иногда полезно знать: что вы можете оптимизировать эти функции, чтобы они вызывались реже. Сохраните таблицу в файле profiling-ncalls.txt
* На этот раз используйте библиотеку pstats. Сортируйте по совокупному времени и получите 5 лучших Сохраните ее в файле pstats-cumulative.txt